# 六边形架构

[视频链接](https://www.bilibili.com/video/BV1194y1H719){target="\_blank"}

## 什么是依赖

对于程序单元A和B来说

`编译依赖`：如果要编译A，必须使用B的编译结果，则在编译期A依赖于B
`运行依赖`：在运行期，如果B不能运行，则A一定也不能运行，则A在运行期依赖于B
`语义依赖`：如果要理解A的语义，必须先要理解B的语义，那么A在语义上依赖于B

## ~~DDD四层架构~~ 已过时

<mermaid>
graph LR
展示层 --> 应用层
应用层 --> 领域层
领域层 --> 基础设施层
</mermaid>

- 上层在语义、编译、运行上都依赖下层
- **领域层依赖基础设施层，是这个架构最大的弊端。** 导致领域模型代码依赖具体实现，难以区分，难以管理，给建模带来困难

## 六边形架构介绍

<mermaid>
graph LR
subgraph 非领域代码
领域核心模块((领域核心模块))
end
</mermaid>

DDD追求领域模型代码不对别的代码产生语义依赖，而编译依赖必定导致语义依赖，因此领域模型代码应该部队别的代码产生编译依赖

### 领域项目

在项目代码中增加一个领域子项目，不依赖其他项目（实践中为了技术实现方便，可以依赖一些工具类项目）

<mermaid>
graph LR
主项目 --编译依赖--> 领域模块
</mermaid>

### 依赖反转

- 依赖反转：领域模块中要使用非领域功能，只需要定义接口，在领域模块外实现该接口
- 不是所有的功能都在领域内定义接口，只有那些不可再分解为领域逻辑的功能才定义为接口
- 在领域模块内定义的接口，应该使用领域模型的语言，不要对实现产生语义依赖

<mermaid>
graph TD
subgraph 非领域模块
领域功能适配器 --使用--> 非领域功能
end
subgraph 领域模块
领域对象 --使用--> 领域功能接口
end
领域功能适配器 <--> 依赖反转
领域功能接口 <--> 依赖反转
</mermaid>

## 例子：在领域模块中表达代客下单

### 不好的设计

```kt
// 这里明显让人感觉是在调用RPC接口，而且也没有表达出来“代客”
OrderRpcService.createOrder(CreateOrderRequest)
```

### 好的设计

```kt
// 用领域的语言去描述，不会依赖具体实现的语义
OrderService.createOrderForCustomerBySystem(CustomerId, Goods, DeliveryDestination)
```
